---
phase: 09-stripe-billing
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - app/app/api/stripe/webhook/route.ts
autonomous: true

must_haves:
  truths:
    - "Checkout completion updates subscription to paid plan"
    - "Subscription cancellation downgrades to free plan"
    - "Payment failure marks subscription as past_due"
    - "User sees correct plan after subscription change"
  artifacts:
    - path: "app/app/api/stripe/webhook/route.ts"
      provides: "Webhook handlers that update database"
      contains: "supabase.*subscriptions.*update"
  key_links:
    - from: "Stripe webhook"
      to: "subscriptions table"
      via: "upsert on checkout.session.completed"
      pattern: "checkout.session.completed.*upsert"
    - from: "Stripe webhook"
      to: "subscriptions table"
      via: "update on subscription events"
      pattern: "customer.subscription.*update"

user_setup:
  - service: stripe
    why: "Webhook requires signing secret for signature validation"
    env_vars:
      - name: STRIPE_WEBHOOK_SECRET
        source: "After running 'stripe listen', copy the webhook signing secret (whsec_...)"
    dashboard_config:
      - task: "Create webhook endpoint (production)"
        location: "Stripe Dashboard → Developers → Webhooks → Add endpoint"
        details: "URL: https://[your-domain]/api/stripe/webhook, Events: checkout.session.completed, customer.subscription.created, customer.subscription.updated, customer.subscription.deleted, invoice.payment_succeeded, invoice.payment_failed"
    local_dev:
      - "stripe listen --forward-to localhost:3000/api/stripe/webhook"
---

<objective>
Implement Stripe webhook handlers to update subscriptions table when payment events occur.

Purpose: Keep database subscription state synchronized with Stripe's subscription lifecycle.
Output: Webhook handlers that process checkout completion, subscription changes, and payment events.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context (checkout creates customers)
@.planning/phases/09-stripe-billing/09-01-SUMMARY.md

# Existing webhook scaffold (has TODOs to implement)
@app/app/api/stripe/webhook/route.ts

# Database schema
@app/supabase/migrations/20260116010000_initial_schema.sql

# Supabase server client pattern
@app/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement webhook handlers for subscription lifecycle</name>
  <files>app/app/api/stripe/webhook/route.ts</files>
  <action>
    Update the existing webhook handler to implement the TODO cases with actual database operations.

    Add Supabase server client import at top:
    ```typescript
    import { createSupabaseServerClient } from '@/lib/supabase/server';
    ```

    Implement each webhook case:

    **checkout.session.completed:**
    ```typescript
    const session = event.data.object as Stripe.Checkout.Session;
    const customerId = session.customer as string;
    const userId = session.metadata?.user_id;

    if (!userId) {
      console.error('[Stripe Webhook] No user_id in checkout metadata');
      break;
    }

    // Get subscription details from Stripe
    const subscriptionId = session.subscription as string;
    const subscription = await stripe.subscriptions.retrieve(subscriptionId);

    // Determine plan from price ID
    const priceId = subscription.items.data[0]?.price.id;
    const plan = getPlanFromPriceId(priceId);

    // Update subscriptions table
    const supabase = await createSupabaseServerClient();
    await supabase.from('subscriptions').upsert({
      user_id: userId,
      stripe_customer_id: customerId,
      plan: plan,
      status: 'active',
      period_start: new Date(subscription.current_period_start * 1000).toISOString(),
      period_end: new Date(subscription.current_period_end * 1000).toISOString(),
    });
    ```

    **customer.subscription.created / customer.subscription.updated:**
    ```typescript
    const subscription = event.data.object as Stripe.Subscription;
    const customerId = subscription.customer as string;
    const priceId = subscription.items.data[0]?.price.id;
    const plan = getPlanFromPriceId(priceId);
    const status = mapStripeStatus(subscription.status);

    const supabase = await createSupabaseServerClient();
    await supabase.from('subscriptions')
      .update({
        plan: plan,
        status: status,
        period_start: new Date(subscription.current_period_start * 1000).toISOString(),
        period_end: new Date(subscription.current_period_end * 1000).toISOString(),
      })
      .eq('stripe_customer_id', customerId);
    ```

    **customer.subscription.deleted:**
    ```typescript
    const subscription = event.data.object as Stripe.Subscription;
    const customerId = subscription.customer as string;

    const supabase = await createSupabaseServerClient();
    await supabase.from('subscriptions')
      .update({
        plan: 'free',
        status: 'canceled',
      })
      .eq('stripe_customer_id', customerId);
    ```

    **invoice.payment_failed:**
    ```typescript
    const invoice = event.data.object as Stripe.Invoice;
    const customerId = invoice.customer as string;

    const supabase = await createSupabaseServerClient();
    await supabase.from('subscriptions')
      .update({ status: 'past_due' })
      .eq('stripe_customer_id', customerId);
    ```

    Add helper functions before POST handler:

    ```typescript
    function getPlanFromPriceId(priceId: string | undefined): 'free' | 'plus' | 'pro' {
      if (priceId === process.env.STRIPE_PRICE_ID_PLUS) return 'plus';
      if (priceId === process.env.STRIPE_PRICE_ID_PRO) return 'pro';
      return 'free';
    }

    function mapStripeStatus(stripeStatus: Stripe.Subscription.Status): 'active' | 'past_due' | 'canceled' | 'trialing' {
      switch (stripeStatus) {
        case 'active': return 'active';
        case 'past_due': return 'past_due';
        case 'canceled':
        case 'unpaid':
        case 'incomplete_expired': return 'canceled';
        case 'trialing': return 'trialing';
        default: return 'active';
      }
    }
    ```

    Error handling for each case:
    - Wrap database operations in try/catch
    - Log errors with [Stripe Webhook] prefix
    - Continue processing (don't fail entire webhook) - Stripe will retry

    Keep the existing signature validation and Stripe client initialization unchanged.
  </action>
  <verify>
    - TypeScript compiles: cd app && pnpm typecheck
    - Build passes: cd app && pnpm build
    - Test with Stripe CLI: stripe trigger checkout.session.completed
    - Test with Stripe CLI: stripe trigger customer.subscription.deleted
    - Verify database updates occur (check subscriptions table)
  </verify>
  <done>Webhook handlers update subscriptions table for all subscription lifecycle events</done>
</task>

<task type="auto">
  <name>Task 2: Verify usage stats integration</name>
  <files>app/app/(protected)/billing/page.tsx</files>
  <action>
    Review and verify the billing page correctly displays usage statistics.

    The billing page already:
    1. Fetches subscription from subscriptions table
    2. Fetches usage from credits_ledger table
    3. Counts templates from templates_personal table

    Verify the credits_ledger query is correct:
    - Filters by current month (startOfMonth to now)
    - Filters by negative delta (credits spent, not added)
    - Correctly counts 'report_generated' actions
    - Correctly sums transcription minutes

    The existing implementation looks correct. If any issues found, fix them:
    - The query uses `.lt('amount', 0)` but schema uses `delta` not `amount`
    - Fix to use `.lt('delta', 0)` if needed
    - The query filters by `action` but schema uses `reason` enum
    - Fix to use `reason` column if needed

    Check the schema:
    ```sql
    CREATE TABLE credits_ledger (
      delta INTEGER NOT NULL,
      reason credit_reason NOT NULL,
      ...
    );
    ```

    If column names don't match, update the query to use:
    - `delta` instead of `amount`
    - `reason` instead of `action`

    Also verify data-testid attributes exist for key metrics so E2E tests can verify:
    - data-testid="billing-reports-count" - exists ✓
    - data-testid="billing-transcription-minutes" - exists ✓
    - data-testid="billing-templates-count" - exists ✓
  </action>
  <verify>
    - TypeScript compiles: cd app && pnpm typecheck
    - Query column names match database schema
    - Usage displays correctly on billing page (manual check)
  </verify>
  <done>Usage statistics correctly read from credits_ledger and display on billing page</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd app && pnpm typecheck` passes
- [ ] `cd app && pnpm build` passes
- [ ] Webhook handlers use Supabase to update subscriptions table
- [ ] checkout.session.completed sets plan and period dates
- [ ] customer.subscription.deleted sets plan to 'free'
- [ ] invoice.payment_failed sets status to 'past_due'
- [ ] Usage stats query uses correct column names from schema
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Webhook handlers process Stripe events and update database
- Usage statistics display correctly on billing page
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-stripe-billing/09-02-SUMMARY.md`
</output>
