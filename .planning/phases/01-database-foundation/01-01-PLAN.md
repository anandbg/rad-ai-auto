---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/supabase/migrations/20260116_001_initial_schema.sql
  - app/supabase/migrations/20260116_002_rls_policies.sql
autonomous: true

must_haves:
  truths:
    - "Supabase tables exist matching codebase type definitions"
    - "User can only read their own profiles row"
    - "User can only CRUD their own templates_personal rows"
    - "User can read published templates_global but only admin can write"
    - "User can only access their own credits_ledger entries"
    - "User can only access their own user_preferences row"
  artifacts:
    - path: "app/supabase/migrations/20260116_001_initial_schema.sql"
      provides: "Database schema creation"
      contains: "CREATE TABLE"
    - path: "app/supabase/migrations/20260116_002_rls_policies.sql"
      provides: "RLS policy definitions"
      contains: "CREATE POLICY"
  key_links:
    - from: "app/types/database.ts"
      to: "Supabase tables"
      via: "Type definitions match table columns"
    - from: "RLS policies"
      to: "auth.uid()"
      via: "User isolation enforcement"
---

<objective>
Create and verify Supabase database schema with Row-Level Security policies.

Purpose: Establish the data foundation that all other features depend on. Without proper schema and RLS, user data isolation cannot be guaranteed.

Output: SQL migration files that create tables matching codebase types and RLS policies enforcing user-level data isolation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Codebase context
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

# Type definitions to align against
@app/types/database.ts

# Supabase client setup
@app/lib/supabase/client.ts
@app/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create initial schema migration</name>
  <files>app/supabase/migrations/20260116_001_initial_schema.sql</files>
  <action>
    Create SQL migration file that creates all tables defined in `app/types/database.ts`:

    **Core tables (in dependency order):**
    1. `profiles` - User profiles linked to auth.users
    2. `institutions` - Organizations (future use, create structure)
    3. `institution_members` - User-institution relationships
    4. `templates_global` - Admin-managed global templates
    5. `templates_personal` - User-owned templates
    6. `template_versions` - Version history for templates
    7. `brand_templates` - User branding configurations
    8. `transcription_macros` - Text replacement shortcuts
    9. `macro_categories` - Macro organization
    10. `subscriptions` - Stripe subscription state
    11. `subscription_limits` - Plan feature limits (reference table)
    12. `credits_ledger` - Credit transactions
    13. `report_sessions` - AI generation history
    14. `transcribe_sessions` - Whisper transcription history
    15. `user_preferences` - User settings

    **Column types must match TypeScript interfaces exactly:**
    - `UserRole` → `user_role` enum ('radiologist', 'admin')
    - `SubscriptionPlan` → `subscription_plan` enum ('free', 'plus', 'pro')
    - `TemplateType` → `template_type` enum ('global', 'personal')
    - JSONB for: style_preferences, branding_defaults, content, tags, meta, template_ref, etc.
    - UUID for all id fields
    - TIMESTAMPTZ for all timestamp fields

    **Foreign key constraints:**
    - `profiles.user_id` → `auth.users(id)` ON DELETE CASCADE
    - `templates_personal.user_id` → `auth.users(id)` ON DELETE CASCADE
    - `templates_personal.origin_global_id` → `templates_global(id)` ON DELETE SET NULL
    - Similar cascading for all user-owned tables

    **Indexes:**
    - `profiles(user_id)` - Primary lookup
    - `templates_personal(user_id)` - User template listing
    - `templates_global(is_published)` - Published template filtering
    - `credits_ledger(user_id, created_at)` - Usage queries
  </action>
  <verify>
    Apply migration to Supabase:
    ```bash
    cd app && npx supabase db push
    ```
    Or if using Supabase CLI:
    ```bash
    supabase migration up
    ```
    Should complete without SQL errors.
  </verify>
  <done>
    All 15 tables created with correct column types, foreign keys, and indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies migration</name>
  <files>app/supabase/migrations/20260116_002_rls_policies.sql</files>
  <action>
    Create SQL migration file with Row-Level Security policies:

    **Enable RLS on all tables:**
    ```sql
    ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;
    ```

    **Policy patterns by access model:**

    1. **User-owned data (profiles, user_preferences, brand_templates, transcription_macros, macro_categories, subscriptions, credits_ledger, report_sessions, transcribe_sessions):**
       - SELECT: `auth.uid() = user_id`
       - INSERT: `auth.uid() = user_id`
       - UPDATE: `auth.uid() = user_id`
       - DELETE: `auth.uid() = user_id`

    2. **User templates (templates_personal):**
       - SELECT: `auth.uid() = user_id`
       - INSERT: `auth.uid() = user_id`
       - UPDATE: `auth.uid() = user_id`
       - DELETE: `auth.uid() = user_id`

    3. **Global templates (templates_global):**
       - SELECT (all users): `is_published = true`
       - SELECT (admin): Full access when user role is admin
       - INSERT/UPDATE/DELETE (admin only): Check profile.role = 'admin'
       ```sql
       CREATE POLICY "Admin can manage global templates"
       ON templates_global FOR ALL
       USING (
         EXISTS (
           SELECT 1 FROM profiles
           WHERE profiles.user_id = auth.uid()
           AND profiles.role = 'admin'
         )
       );
       ```

    4. **Subscription limits (reference data):**
       - SELECT: Allow all authenticated users
       - INSERT/UPDATE/DELETE: Admin only

    5. **Template versions:**
       - Access based on parent template ownership

    **Important:** Use `WITH CHECK` for INSERT/UPDATE policies to validate data being written.

    **Do NOT:**
    - Create overly permissive policies
    - Forget to enable RLS (tables without RLS enabled are public!)
    - Use service role key in client-side code
  </action>
  <verify>
    Test RLS policies with SQL in Supabase SQL Editor:
    ```sql
    -- As authenticated user (simulated)
    SET request.jwt.claims = '{"sub": "test-user-uuid"}';

    -- Should return only user's own profile
    SELECT * FROM profiles;

    -- Should return only published global templates
    SELECT * FROM templates_global;

    -- Should fail (inserting to another user's data)
    INSERT INTO profiles (user_id, name) VALUES ('other-user-uuid', 'Hacker');
    ```
  </verify>
  <done>
    RLS enabled on all tables. Policies enforce: user can only access own data, global templates readable by all when published, admin-only write access for global templates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify schema alignment with codebase types</name>
  <files>app/types/database.ts</files>
  <action>
    Verify the created schema matches TypeScript types:

    1. **Generate types from Supabase:**
       ```bash
       cd app && npx supabase gen types typescript --local > types/supabase.ts
       ```
       Or if connected to remote:
       ```bash
       npx supabase gen types typescript --project-id YOUR_PROJECT_ID > types/supabase.ts
       ```

    2. **Compare generated types with database.ts:**
       - Check each interface in `database.ts` has corresponding table
       - Verify column names match (snake_case in SQL, same in TS interfaces)
       - Verify column types match (string, number, boolean, JSON objects)
       - Note any discrepancies for follow-up

    3. **Test basic queries work:**
       Create a simple test script or use the existing API routes to verify:
       - Can read from `profiles` table
       - Can read from `templates_global` table
       - Supabase client connection works

    **If mismatches found:**
    - Document them in the SUMMARY
    - Create additional migration if needed
    - Update TypeScript types if database is source of truth

    **Do NOT:**
    - Silently ignore type mismatches
    - Assume generated types are always correct (verify manually)
  </action>
  <verify>
    ```bash
    # Type check passes
    cd app && pnpm typecheck

    # Or verify manually that types/supabase.ts exists and has table definitions
    ```
  </verify>
  <done>
    Generated Supabase types match codebase expectations. Any discrepancies documented. TypeScript type check passes.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Schema migration applies without SQL errors
- [ ] RLS policies migration applies without SQL errors
- [ ] All 15 tables exist in Supabase
- [ ] RLS is enabled on all tables (verify in Supabase dashboard > Authentication > Policies)
- [ ] Basic query test succeeds (profiles table readable)
- [ ] `pnpm typecheck` passes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Schema matches TypeScript type definitions
- RLS policies enforce user-level data isolation
- Requirements DB-01 and DB-02 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md` with:
- Schema creation results
- RLS policy implementation details
- Any type mismatches found and how they were resolved
- Key decisions made during implementation
</output>
