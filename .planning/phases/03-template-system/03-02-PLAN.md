---
phase: 03-template-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/app/(protected)/templates/page.tsx
  - app/app/(protected)/templates/new/page.tsx
  - app/app/(protected)/templates/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Template list page loads templates from API"
    - "Creating a template saves to database (not localStorage)"
    - "Editing a template updates database (not localStorage)"
    - "Deleting a template removes from database"
    - "Cloning a global template creates personal copy in database"
    - "localStorage helpers are removed from template pages"
  artifacts:
    - path: "app/app/(protected)/templates/page.tsx"
      provides: "Template list with database CRUD"
      min_lines: 200
    - path: "app/app/(protected)/templates/new/page.tsx"
      provides: "Create template form using API"
      min_lines: 200
    - path: "app/app/(protected)/templates/[id]/page.tsx"
      provides: "Edit template form using API"
      min_lines: 200
  key_links:
    - from: "templates/new/page.tsx handleSubmit"
      to: "POST /api/templates"
      via: "fetch call"
      pattern: "fetch.*api/templates.*POST"
    - from: "templates/[id]/page.tsx handleSave"
      to: "PUT /api/templates/[id]"
      via: "fetch call"
      pattern: "fetch.*api/templates.*PUT"
    - from: "templates/page.tsx confirmDelete"
      to: "DELETE /api/templates/[id]"
      via: "fetch call"
      pattern: "fetch.*api/templates.*DELETE"
    - from: "templates/page.tsx confirmClone"
      to: "POST /api/templates/clone"
      via: "fetch call"
      pattern: "fetch.*api/templates/clone.*POST"
---

<objective>
Connect template UI pages to database API endpoints, removing localStorage usage.

Purpose: Complete the template system by wiring frontend forms to real database operations.
Output: Template CRUD operations use API routes created in Plan 01.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Prior work - API endpoints created in Plan 01
@.planning/phases/03-template-system/03-01-SUMMARY.md

# Source files to modify
@app/app/(protected)/templates/page.tsx
@app/app/(protected)/templates/new/page.tsx
@app/app/(protected)/templates/[id]/page.tsx

# Validation schema (keep using this)
@app/lib/validation/template-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update templates list page to use DELETE and clone APIs</name>
  <files>app/app/(protected)/templates/page.tsx</files>
  <action>
    The list page already loads from Supabase via the browser client. Update delete and clone operations:

    **Delete operation (confirmDelete function):**
    1. Replace direct Supabase delete with API call:
       ```typescript
       const response = await fetch(`/api/templates/${templateToDelete.id}`, {
         method: 'DELETE',
       });
       if (!response.ok) {
         const data = await response.json();
         throw new Error(data.message || 'Failed to delete template');
       }
       ```
    2. Keep local state update and toast notification

    **Clone operation (confirmClone function):**
    1. Replace direct Supabase insert with API call:
       ```typescript
       const response = await fetch('/api/templates/clone', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
           globalTemplateId: templateToClone.id,
           name: cloneName.trim() || undefined,
         }),
       });
       if (!response.ok) {
         const data = await response.json();
         throw new Error(data.message || 'Failed to clone template');
       }
       const { data: newTemplate } = await response.json();
       ```
    2. Update local state with returned template data

    **Bulk delete operation (confirmBulkDelete function):**
    1. Loop through selected IDs and call DELETE endpoint for each
    2. Use Promise.all for parallel deletion (or sequential if preferred)

    Do NOT change the loadTemplates function - it correctly uses Supabase browser client which is fine for reads (RLS handles security).
  </action>
  <verify>
    - Delete a personal template → removed from list, refresh shows it's gone from database
    - Clone a global template → appears in personal list with new ID
    - Bulk delete works correctly
  </verify>
  <done>Template list page delete and clone operations use API endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Update new template page to POST via API</name>
  <files>app/app/(protected)/templates/new/page.tsx</files>
  <action>
    Replace localStorage-based template creation with API call:

    1. Remove these localStorage helper functions (no longer needed):
       - getStoredTemplates
       - saveTemplates
       - getGlobalTemplates
       - saveGlobalTemplates
       - generateId
       - getStorageKey

    2. Keep draft storage functions (saveDraft, loadDraft, clearDraft) - drafts in localStorage are useful for form recovery.

    3. Update handleSubmit:
       ```typescript
       const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
         e.preventDefault();

         // Validate CSRF token (keep existing)
         const formDataObj = new FormData(e.currentTarget);
         const csrfToken = formDataObj.get('_csrf') as string;
         if (!validateToken(csrfToken)) {
           showToast('Security validation failed. Please refresh and try again.', 'error');
           return;
         }

         if (!validateForm()) return;
         setIsSubmitting(true);

         try {
           const response = await fetch('/api/templates', {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({
               name: formData.name.trim(),
               modality: formData.modality,
               bodyPart: formData.bodyPart,
               description: formData.description.trim(),
               content: formData.content,
               sections: sections.length > 0 ? sections : undefined,
             }),
           });

           if (!response.ok) {
             const data = await response.json();
             if (data.validationErrors) {
               setErrors(data.validationErrors);
               return;
             }
             throw new Error(data.message || 'Failed to create template');
           }

           const { data: newTemplate } = await response.json();
           clearDraft(user?.id);
           showToast(`Template "${newTemplate.name}" created successfully!`, 'success');
           router.push('/templates');
         } catch (error) {
           console.error('Error creating template:', error);
           showToast(error instanceof Error ? error.message : 'Failed to create template', 'error');
         } finally {
           setIsSubmitting(false);
         }
       };
       ```

    4. Update validateForm to remove duplicate name check against localStorage (server handles this).

    5. Remove isGlobal checkbox and state (admin global template creation is out of scope for v1 - roadmap says Phase 10 handles admin features).
  </action>
  <verify>
    - Create new template → saves to database, appears in list after redirect
    - Validation errors show correctly (try submitting empty form)
    - Draft auto-save still works (form recovery on page refresh)
    - Creating duplicate name shows server validation error
  </verify>
  <done>New template page creates templates via API, not localStorage</done>
</task>

<task type="auto">
  <name>Task 3: Update edit template page to use GET/PUT API</name>
  <files>app/app/(protected)/templates/[id]/page.tsx</files>
  <action>
    Replace localStorage-based template loading and saving with API calls:

    1. Remove localStorage helper functions (same as Task 2).

    2. Update template loading (useEffect that fetches template):
       ```typescript
       useEffect(() => {
         const loadTemplate = async () => {
           if (!params.id) {
             setError('Template ID not found');
             setIsLoading(false);
             return;
           }

           try {
             const response = await fetch(`/api/templates/${params.id}`);
             if (!response.ok) {
               if (response.status === 404) {
                 setError('Template not found');
               } else {
                 setError('Failed to load template');
               }
               setIsLoading(false);
               return;
             }

             const { data: templateData } = await response.json();
             setTemplate(templateData);
             setFormData({
               name: templateData.name,
               modality: templateData.modality,
               bodyPart: templateData.bodyPart || templateData.body_part,
               description: templateData.description || '',
               content: templateData.content?.rawContent || '',
             });
             setSections(templateData.content?.sections || []);
             setIsGlobal(templateData.isGlobal || false);
           } catch (err) {
             console.error('Error loading template:', err);
             setError('Failed to load template');
           } finally {
             setIsLoading(false);
           }
         };

         loadTemplate();
       }, [params.id]);
       ```

    3. Update handleSave function:
       ```typescript
       const handleSave = async () => {
         if (!validateForm()) return;
         setIsSaving(true);

         try {
           const response = await fetch(`/api/templates/${params.id}`, {
             method: 'PUT',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({
               name: formData.name.trim(),
               modality: formData.modality,
               bodyPart: formData.bodyPart,
               description: formData.description.trim(),
               content: formData.content,
               sections: sections.length > 0 ? sections : undefined,
             }),
           });

           if (!response.ok) {
             const data = await response.json();
             if (data.validationErrors) {
               setErrors(data.validationErrors);
               return;
             }
             throw new Error(data.message || 'Failed to update template');
           }

           const { data: updatedTemplate } = await response.json();
           setOriginalData({
             name: updatedTemplate.name,
             modality: updatedTemplate.modality,
             bodyPart: updatedTemplate.body_part,
             description: updatedTemplate.description,
             content: updatedTemplate.content?.rawContent || '',
           });
           setOriginalSections(updatedTemplate.content?.sections || []);
           setIsDirty(false);
           showToast('Template saved successfully!', 'success');
         } catch (error) {
           console.error('Error saving template:', error);
           showToast(error instanceof Error ? error.message : 'Failed to save template', 'error');
         } finally {
           setIsSaving(false);
         }
       };
       ```

    4. For global templates (isGlobal = true), make the form read-only:
       - Disable all inputs
       - Hide save button
       - Show "Clone to edit" button instead

    5. Keep the unsaved changes detection (isDirty) logic - it's useful UX.
  </action>
  <verify>
    - Load an existing personal template → form populated with data from database
    - Edit and save → changes persisted, visible after refresh
    - Load a global template → form is read-only, shows "Clone to edit" option
    - Unsaved changes warning works when navigating away with edits
  </verify>
  <done>Edit template page loads and saves via API, handles global templates as read-only</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Templates list page: delete and clone use API endpoints
- [ ] New template page: creates via POST /api/templates
- [ ] Edit template page: loads via GET, saves via PUT
- [ ] All localStorage template helpers removed from these pages
- [ ] Draft storage (for form recovery) still works in new template page
- [ ] Global templates shown as read-only in edit page
- [ ] No new TypeScript errors introduced
- [ ] npm run build passes (or only pre-existing errors)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Template CRUD operations work end-to-end with database
- localStorage no longer used for template storage (drafts are OK)
</success_criteria>

<output>
After completion, create `.planning/phases/03-template-system/03-02-SUMMARY.md`
</output>
