---
phase: 03-template-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/app/api/templates/route.ts
  - app/app/api/templates/[id]/route.ts
  - app/app/api/templates/clone/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/templates creates template in database"
    - "GET /api/templates/[id] returns template from database"
    - "PUT /api/templates/[id] updates template in database"
    - "DELETE /api/templates/[id] removes template from database"
    - "POST /api/templates/clone creates personal copy of global template"
    - "Validation errors return 400 with error details"
    - "Unauthenticated requests return 401"
  artifacts:
    - path: "app/app/api/templates/route.ts"
      provides: "Template creation endpoint"
      exports: ["POST"]
    - path: "app/app/api/templates/[id]/route.ts"
      provides: "Template CRUD operations"
      exports: ["GET", "PUT", "DELETE"]
    - path: "app/app/api/templates/clone/route.ts"
      provides: "Global template cloning"
      exports: ["POST"]
  key_links:
    - from: "POST /api/templates"
      to: "supabase.from('templates_personal').insert()"
      via: "Supabase server client"
      pattern: "templates_personal.*insert"
    - from: "PUT /api/templates/[id]"
      to: "supabase.from('templates_personal').update()"
      via: "Supabase server client"
      pattern: "templates_personal.*update"
    - from: "DELETE /api/templates/[id]"
      to: "supabase.from('templates_personal').delete()"
      via: "Supabase server client"
      pattern: "templates_personal.*delete"
    - from: "POST /api/templates/clone"
      to: "supabase.from('templates_global').select() then templates_personal.insert()"
      via: "Supabase server client"
      pattern: "templates_global.*select.*templates_personal.*insert"
---

<objective>
Create API endpoints for template CRUD operations connected to Supabase database.

Purpose: Enable frontend to create, read, update, and delete templates via API instead of localStorage.
Output: Three API route files providing full template management capability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Prior work
@.planning/phases/02-authentication/02-01-SUMMARY.md

# Existing code to reference
@app/app/api/templates/list/route.ts
@app/app/api/templates/validate/route.ts
@app/lib/supabase/server.ts
@app/lib/validation/template-schema.ts

# Database schema reference
@app/supabase/migrations/20260116_001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /api/templates endpoint</name>
  <files>app/app/api/templates/route.ts</files>
  <action>
    Create POST endpoint for personal template creation:

    1. Import createSupabaseServerClient from @/lib/supabase/server
    2. Import templateFormSchema from @/lib/validation/template-schema
    3. Authenticate user using supabase.auth.getUser() - return 401 if not authenticated
    4. Parse and validate request body with templateFormSchema.safeParse()
    5. Return 400 with validation errors if validation fails (use formatZodErrors)
    6. Map form data to database columns:
       - name → name
       - modality → modality
       - bodyPart → body_part
       - description → description
       - content → content (store as JSONB: { sections: [], rawContent: string })
       - user_id → auth user id
    7. Insert into templates_personal using supabase.from('templates_personal').insert()
    8. Return 201 with created template data

    Follow existing patterns from /api/templates/validate/route.ts for error handling.
    Use consistent response format: { success: boolean, data?: T, error?: string, message?: string }
  </action>
  <verify>
    curl -X POST http://localhost:3000/api/templates \
      -H "Content-Type: application/json" \
      -H "Cookie: [auth-cookie]" \
      -d '{"name":"Test Template","modality":"CT","bodyPart":"Chest","description":"Test description for template"}' \
    returns 201 with template data including id
  </verify>
  <done>POST /api/templates creates template in database and returns 201</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/templates/[id] route handler</name>
  <files>app/app/api/templates/[id]/route.ts</files>
  <action>
    Create route handler with GET, PUT, DELETE methods:

    **GET handler:**
    1. Authenticate user
    2. Extract template id from params
    3. Query templates_personal with .eq('id', id).eq('user_id', userId).single()
    4. If not found, also check templates_global with .eq('id', id).eq('is_published', true).single()
    5. Return 404 if not found in either table
    6. Return template data with isGlobal flag

    **PUT handler:**
    1. Authenticate user
    2. Validate request body with templateFormSchema
    3. Update templates_personal where id matches AND user_id matches (RLS enforces this too)
    4. Return 404 if no rows updated
    5. Return updated template

    **DELETE handler:**
    1. Authenticate user
    2. Delete from templates_personal where id matches AND user_id matches
    3. Return 404 if no rows deleted
    4. Return 204 No Content on success

    Important: Users cannot modify or delete global templates (RLS prevents this).
  </action>
  <verify>
    - GET /api/templates/[valid-id] returns 200 with template data
    - PUT /api/templates/[valid-id] with valid body returns 200 with updated data
    - DELETE /api/templates/[valid-id] returns 204
    - All endpoints return 401 without auth, 404 for invalid id
  </verify>
  <done>GET, PUT, DELETE endpoints work correctly with proper auth and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create POST /api/templates/clone endpoint</name>
  <files>app/app/api/templates/clone/route.ts</files>
  <action>
    Create POST endpoint to clone a global template to personal collection:

    1. Authenticate user
    2. Parse request body: { globalTemplateId: string, name?: string }
    3. Fetch the global template from templates_global where id matches AND is_published = true
    4. Return 404 if global template not found
    5. Create new personal template:
       - Copy all fields (name, modality, body_part, description, content)
       - Use provided name OR append " (Copy)" to original name
       - Set origin_global_id to the source global template id
       - Set user_id to authenticated user
    6. Insert into templates_personal
    7. Return 201 with new personal template data

    This enables users to clone published global templates for personal customization.
  </action>
  <verify>
    curl -X POST http://localhost:3000/api/templates/clone \
      -H "Content-Type: application/json" \
      -H "Cookie: [auth-cookie]" \
      -d '{"globalTemplateId":"[valid-global-template-id]"}' \
    returns 201 with new personal template that has origin_global_id set
  </verify>
  <done>POST /api/templates/clone creates personal copy of global template</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All three route files created and TypeScript compiles
- [ ] POST /api/templates creates templates in database
- [ ] GET /api/templates/[id] retrieves templates (personal and global)
- [ ] PUT /api/templates/[id] updates personal templates
- [ ] DELETE /api/templates/[id] removes personal templates
- [ ] POST /api/templates/clone creates personal copies of global templates
- [ ] All endpoints return 401 for unauthenticated requests
- [ ] Validation errors return 400 with structured error response
- [ ] npm run build passes (or only pre-existing errors)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- API endpoints follow existing codebase conventions
- No new TypeScript errors introduced (pre-existing errors acceptable)
</success_criteria>

<output>
After completion, create `.planning/phases/03-template-system/03-01-SUMMARY.md`
</output>
