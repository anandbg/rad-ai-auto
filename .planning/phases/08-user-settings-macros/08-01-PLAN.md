---
phase: 08-user-settings-macros
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/preferences/preferences-context.tsx
  - app/app/api/preferences/route.ts
autonomous: true

must_haves:
  truths:
    - "User preferences persist across browser sessions"
    - "User preferences sync across tabs"
    - "Theme preference changes are reflected immediately"
    - "Default template selection is saved to database"
  artifacts:
    - path: "app/app/api/preferences/route.ts"
      provides: "Preferences CRUD API"
      exports: ["GET", "PUT"]
    - path: "app/lib/preferences/preferences-context.tsx"
      provides: "Preferences state management connected to database"
      contains: "fetch.*api/preferences"
  key_links:
    - from: "preferences-context.tsx"
      to: "/api/preferences"
      via: "fetch on load and updatePreference"
      pattern: "fetch.*api/preferences"
    - from: "/api/preferences"
      to: "user_preferences table"
      via: "Supabase client"
      pattern: "supabase.*user_preferences"
---

<objective>
Connect user preferences to the database via API routes.

Purpose: Replace localStorage-based preferences with real database persistence so preferences survive browser changes and sync across devices.
Output: Working preferences API and updated PreferencesContext that loads/saves to database.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Database schema reference
@app/supabase/migrations/20260116010000_initial_schema.sql (lines 300-311 for user_preferences table)

# Existing implementation to modify
@app/lib/preferences/preferences-context.tsx

# Auth context pattern for Supabase client usage
@app/lib/auth/auth-context.tsx

# API route patterns from templates
@app/app/api/templates/list/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create preferences API route</name>
  <files>app/app/api/preferences/route.ts</files>
  <action>
    Create API route for user preferences CRUD:

    GET /api/preferences:
    - Authenticate user via createSupabaseServerClient
    - Query user_preferences table for user_id
    - If no row exists, return default preferences (don't auto-create - let PUT handle that)
    - Return JSON with theme, default_template_id, yolo_mode_enabled, keyboard_shortcuts_enabled, onboarding_completed

    PUT /api/preferences:
    - Authenticate user via createSupabaseServerClient
    - Parse request body for preference updates
    - UPSERT to user_preferences table (insert if not exists, update if exists)
    - Return updated preferences

    Map database columns to frontend interface:
    - theme (TEXT) → theme ('light' | 'dark' | 'system')
    - default_template_id (UUID) → defaultTemplate (string | null)
    - yolo_mode_enabled (BOOLEAN) → yoloMode (boolean)
    - keyboard_shortcuts_enabled (BOOLEAN) → autoSave (boolean) -- Note: reusing as autoSave for now
    - onboarding_completed (BOOLEAN) → onboardingCompleted (boolean)

    Note: compactMode doesn't exist in DB schema - keep it in localStorage or ignore for now.

    Follow existing API patterns from templates/list/route.ts for error handling and response format.
  </action>
  <verify>curl -X GET localhost:3000/api/preferences (with auth) returns JSON preferences</verify>
  <done>GET returns preferences, PUT updates/creates preferences record</done>
</task>

<task type="auto">
  <name>Task 2: Update PreferencesContext to use API</name>
  <files>app/lib/preferences/preferences-context.tsx</files>
  <action>
    Modify PreferencesContext to load from and save to API:

    1. On mount (useEffect):
       - Fetch GET /api/preferences
       - If successful, merge with DEFAULT_PREFERENCES and set state
       - Keep localStorage as fallback for offline/error scenarios
       - Also keep localStorage for compactMode (not in DB)

    2. updatePreference function:
       - Optimistically update local state
       - Call PUT /api/preferences with updated preferences
       - If API fails, log error but don't revert (optimistic update)
       - For compactMode, only save to localStorage (not in DB)

    3. Add error handling:
       - If user not authenticated, fall back to localStorage-only mode
       - Log API errors but don't break the UI

    4. Keep localStorage sync for cross-tab updates (existing dispatchEvent logic)

    Maintain backwards compatibility: if API fails, preferences still work via localStorage.
  </action>
  <verify>
    - npm run build succeeds
    - Change theme in settings, refresh page - theme persists
    - Open new tab - preferences are synchronized
  </verify>
  <done>Preferences load from API on mount, save to API on change, with localStorage fallback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds without errors
- [ ] GET /api/preferences returns user preferences
- [ ] PUT /api/preferences updates preferences in database
- [ ] PreferencesContext loads from API on mount
- [ ] Theme changes persist across page refresh
- [ ] Default template selection persists across sessions
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Preferences are stored in user_preferences table
- UI continues to work (theme, default template)
- localStorage fallback works when API unavailable
  </success_criteria>

<output>
After completion, create `.planning/phases/08-user-settings-macros/08-01-SUMMARY.md`
</output>
