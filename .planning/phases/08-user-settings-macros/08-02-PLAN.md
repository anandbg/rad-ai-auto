---
phase: 08-user-settings-macros
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/app/api/macros/route.ts
  - app/app/api/macros/[id]/route.ts
  - app/app/api/macros/categories/route.ts
  - app/app/api/macros/categories/[id]/route.ts
  - app/app/(protected)/macros/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a new macro that persists in database"
    - "User can edit an existing macro"
    - "User can delete a macro"
    - "User can create and delete macro categories"
    - "Macros load from database on page visit"
  artifacts:
    - path: "app/app/api/macros/route.ts"
      provides: "Macros list and create API"
      exports: ["GET", "POST"]
    - path: "app/app/api/macros/[id]/route.ts"
      provides: "Macro update and delete API"
      exports: ["PUT", "DELETE"]
    - path: "app/app/api/macros/categories/route.ts"
      provides: "Categories list and create API"
      exports: ["GET", "POST"]
    - path: "app/app/api/macros/categories/[id]/route.ts"
      provides: "Category delete API"
      exports: ["DELETE"]
    - path: "app/app/(protected)/macros/page.tsx"
      provides: "Macros UI connected to API"
      contains: "fetch.*api/macros"
  key_links:
    - from: "macros/page.tsx"
      to: "/api/macros"
      via: "fetch for CRUD operations"
      pattern: "fetch.*api/macros"
    - from: "/api/macros"
      to: "transcription_macros table"
      via: "Supabase client"
      pattern: "supabase.*transcription_macros"
    - from: "/api/macros/categories"
      to: "macro_categories table"
      via: "Supabase client"
      pattern: "supabase.*macro_categories"
---

<objective>
Connect macros system to the database via API routes.

Purpose: Replace localStorage-based macros with real database persistence so macros survive browser changes and sync across devices.
Output: Working macros API (CRUD for macros and categories) and updated MacrosPage that loads/saves to database.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Database schema reference
@app/supabase/migrations/20260116010000_initial_schema.sql (lines 178-209 for macros tables)

# Existing implementation to modify
@app/app/(protected)/macros/page.tsx

# API route patterns from templates
@app/app/api/templates/list/route.ts
@app/app/api/templates/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create macros API routes</name>
  <files>app/app/api/macros/route.ts, app/app/api/macros/[id]/route.ts</files>
  <action>
    Create API routes for macros CRUD:

    GET /api/macros:
    - Authenticate user via createSupabaseServerClient
    - Query transcription_macros table for user_id
    - Include category relationship (join or separate query)
    - Return array of macros with all fields

    POST /api/macros:
    - Authenticate user
    - Validate request body (name required, replacement_text required)
    - Insert into transcription_macros with user_id
    - Map frontend fields to DB columns:
      - name → name
      - replacementText → replacement_text
      - isActive → is_active (default true)
      - isSmartMacro → is_smart
      - contextExpansions → smart_context (JSONB)
      - categoryId → category_id
    - Return created macro with id

    PUT /api/macros/[id]:
    - Authenticate user
    - Verify macro belongs to user (RLS handles this, but check exists)
    - Update allowed fields
    - Return updated macro

    DELETE /api/macros/[id]:
    - Authenticate user
    - Delete macro (RLS ensures ownership)
    - Return 204 No Content

    Follow templates API patterns for error handling and response format.
    Use 400 for validation errors, 401 for auth, 404 for not found.
  </action>
  <verify>
    - curl -X GET localhost:3000/api/macros returns array
    - curl -X POST localhost:3000/api/macros with body creates macro
  </verify>
  <done>All macro CRUD operations work via API</done>
</task>

<task type="auto">
  <name>Task 2: Create macro categories API routes</name>
  <files>app/app/api/macros/categories/route.ts, app/app/api/macros/categories/[id]/route.ts</files>
  <action>
    Create API routes for macro categories:

    GET /api/macros/categories:
    - Authenticate user
    - Query macro_categories table for user_id
    - Return array of categories

    POST /api/macros/categories:
    - Authenticate user
    - Validate name required
    - Insert into macro_categories with user_id
    - Return created category with id

    DELETE /api/macros/categories/[id]:
    - Authenticate user
    - Delete category (RLS ensures ownership)
    - Note: DB has ON DELETE SET NULL for macros referencing this category
    - Return 204 No Content

    No PUT needed for categories (only name, can recreate if needed).
  </action>
  <verify>curl -X GET localhost:3000/api/macros/categories returns array</verify>
  <done>Category CRUD operations work via API</done>
</task>

<task type="auto">
  <name>Task 3: Update MacrosPage to use API</name>
  <files>app/app/(protected)/macros/page.tsx</files>
  <action>
    Replace localStorage calls with API calls:

    1. Loading macros (useEffect):
       - Fetch GET /api/macros and GET /api/macros/categories
       - Set state from response
       - Remove localStorage getStoredMacros/getStoredCategories calls

    2. handleCreateMacro:
       - POST /api/macros with macro data
       - Add returned macro to state
       - Remove localStorage saveMacros call

    3. handleEditMacro:
       - PUT /api/macros/[id] with updated data
       - Update state on success
       - Remove localStorage saveMacros call

    4. confirmDeleteMacro:
       - DELETE /api/macros/[id]
       - Remove from state on success
       - Remove localStorage saveMacros call

    5. toggleMacro:
       - PUT /api/macros/[id] with is_active toggle
       - Update state on success

    6. handleCreateCategory:
       - POST /api/macros/categories
       - Add returned category to state

    7. handleDeleteCategory:
       - DELETE /api/macros/categories/[id]
       - Update state on success

    8. handleMoveMacro:
       - PUT /api/macros/[id] with category_id change

    9. Keep global macros separate:
       - Global macros could come from API (is_global=true) or be hardcoded
       - For now, keep the hardcoded globalMacros array (no admin feature yet)
       - Future: fetch global macros from API with is_global=true filter

    10. Error handling:
        - Show toast on API errors
        - Don't break UI on failures

    11. Loading state:
        - Add isLoading state for initial fetch
        - Show loading indicator while fetching
  </action>
  <verify>
    - npm run build succeeds
    - Create macro in UI, refresh page - macro persists
    - Delete macro in UI, refresh page - macro gone
    - Create category, assign macro to it, refresh - all persists
  </verify>
  <done>Macros page fully connected to database via API, localStorage removed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds without errors
- [ ] GET /api/macros returns user's macros
- [ ] POST /api/macros creates a new macro
- [ ] PUT /api/macros/[id] updates a macro
- [ ] DELETE /api/macros/[id] deletes a macro
- [ ] Category CRUD works
- [ ] MacrosPage loads macros from API
- [ ] Create/edit/delete macros persists to database
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Macros are stored in transcription_macros table
- Categories are stored in macro_categories table
- UI operations persist to database
- Global macros still display (hardcoded for now)
  </success_criteria>

<output>
After completion, create `.planning/phases/08-user-settings-macros/08-02-SUMMARY.md`
</output>
